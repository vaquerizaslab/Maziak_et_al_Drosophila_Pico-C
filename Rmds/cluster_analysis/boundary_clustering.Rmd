---
title: "Cluster boundaries by marks"
author: "Fabian"
date: "2025-03-29"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(GenomicRanges)
library(rtracklayer)

library(stringr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggrastr)

library(NbClust)
library(uwot)

set.seed(14)

data_dir <- "path_to_datafiles"

cluster_colours6 <- c(
  "#1395BA",
  "#0D3C55",
  "#C02E1D",
  "#F16C20",
  "#EBC844",
  "#A2B86C"
)

cluster_colours12 <- c(
  # "#a2b86c",
  "#5ca793",
  "#1395ba",
  "#117899",
  # "#0f5b78",
  "#0d3c55",
  "#c02e1d",
  "#d94e1f",
  "#f16c20",
  "#ef8b2c",
  "#a2b86c",
  "#ecaa38",
  "#ebc844"
)

# Change this to TRUE to run the code for optimising clusters
optimise_clusters <- FALSE
```

```{r}
# Load the boundaries for NC14
boundaries <- import(
  file.path(data_dir, "boundary_calls_beds/NC14_0.45_16kb_500bp_boundaries.nocento.bed")
)

# Extend the boundaries to cover 5kb around the center (500bp + 2x 2250bp extension)
boundaries_ext <- boundaries
start(boundaries_ext) <- start(boundaries_ext) - 2250
end(boundaries_ext) <- end(boundaries_ext) + 2250
```

```{r}
# List the bigwig files of the different marks
mark_files <- file.path(data_dir, "marks_bw/*/MBT*") %>% 
  Sys.glob()
mark_files <- file.path(data_dir, "marks_bw", c("H3K4me3", "TBP"),"*_MBT*") %>% 
  Sys.glob() %>% 
  c(mark_files)
mark_names <- str_extract(mark_files, "marks_bw/(.+)/", group = 1)

# List the ATAC files
atac_files <- file.path(data_dir, "marks_bw/ATAC/NC14*") %>% 
  Sys.glob() %>% 
  str_subset("all", negate = TRUE)
atac_names <- str_extract(atac_files, "marks_bw/.+(mono|open).bw", group = 1) %>% 
  paste("ATAC", ., sep = "_")

# List the insulator files
ins_files <- file.path(data_dir, "marks_bw/insulators_furlong/*") %>% 
  Sys.glob()
ins_names <- str_extract(ins_files, "insulators_furlong/([^_]+)_", group = 1)

# Load the signal of all marks in the boundary regions as matrices
mark_matrices <- lapply(
  c(mark_files, atac_files, ins_files),
  function(file) {
    import.bw(
      file,
      selection = BigWigSelection(boundaries_ext),
      as = "NumericList"
    ) %>% 
      as.matrix()
  }
) %>% 
  magrittr::set_names(c(mark_names, atac_names, ins_names))

# Define the regions of center and outside for each mark to calculate the enrichment
regions <- data.frame(
  mark = rep(
    c(
      "CLAMP",
      "H3K27me3",
      "H3K36me3",
      "PolII",
      "RNA",
      "Zld",
      "ATAC_mono",
      "ATAC_open",
      "BEAF",
      "CP190",
      "CTCF",
      "SUHW",
      "TBP",
      "H3K4me3",
      "H4K16ac",
      "GAF"
    ),
    each = 2
  ),
  region = c("center", "outside"),
  start = c(rep(c(-500, -2250), 14), -400, -1100, -500, -2250),
  end = c(rep(c(500, -1000), 14), 400, -400, 500, -1000)
)
```

```{r}
# Calculate the average profile of each signal around all boundaries
mark_average <- lapply(
  mark_matrices,
  function(matrix) {
    data.frame(
      pos = (1:ncol(matrix)) - 2500,
      mean = colMeans(matrix),
      sd = apply(matrix, 2, sd)
    )
  }
) %>% 
  bind_rows(.id = "mark") %>% 
  group_by(mark) %>% 
  mutate(
    norm = (mean - min(mean)) / (max(mean) - min(mean))
  )

# Plot the profile of all marks around the boundaries and highlight the center (red) and outside (blue) regions
region_plot <- ggplot(mark_average) +
  # geom_ribbon(aes(ymin = mean - sd, ymax = mean + sd), alpha = 0.2) +
  geom_rect(
    data = regions %>% filter(region == "center"),
    aes(xmin = start, xmax = end),
    ymin = -Inf, ymax = Inf,
    alpha = 0.1,
    fill = "red"
  ) +
  geom_rect(
    data = regions %>% filter(region == "outside"),
    aes(xmin = start, xmax = end),
    ymin = -Inf, ymax = Inf,
    alpha = 0.1,
    fill = "blue"
  ) +
  geom_rect(
    data = regions %>% filter(region == "outside"),
    aes(xmin = -start, xmax = -end),
    ymin = -Inf, ymax = Inf,
    alpha = 0.1,
    fill = "blue"
  ) +
  geom_line(aes(x = pos, y = mean, colour = mark)) +
  scale_x_continuous(
    labels = scales::label_number(scale_cut = scales::cut_si("b"))
  ) +
  facet_wrap(~ mark, scales = "free_y") +
  guides(
    colour = "none"
  ) +
  labs(
    x = "Position rel. to boundary center",
    y = "Average signal",
    colour = "Mark"
  ) +
  theme_bw() +
  theme(
    panel.grid.minor = element_blank()
  )
region_plot
ggsave("results/1_average_regions_of_enrichment.pdf", region_plot, width = 9, height = 5)
```

```{r}
# Calculate the signal enrichment of marks of the center (red) compared to the outside (blue) regions
marks_enrich <- lapply(
  names(mark_matrices),
  function(name) {
    # Get the signal matrix for the mark
    mat <- mark_matrices[[name]]
    
    # Get the minimum and maximum values for each region
    mins <- apply(mat, 1, min)
    maxs <- apply(mat, 1, max)
    
    # Get the coordinates for the center and outside regions, as defined above
    center <- regions %>% filter(mark == name, region == "center")
    outside <- regions %>% filter(mark == name, region == "outside")
    
    # Get the average signal of center and outside regions
    data.frame(
      boundary = 1:nrow(mat),
      center = (rowMeans(mat[, (2500 + center$start):(2500 + center$end)]) - mins) / (maxs - mins),
      outside = (rowMeans(mat[, c((2500 + outside$start):(2500 + outside$end), (2500 - outside$start):(2500 - outside$end))]) - mins) / (maxs - mins)
    )
  }
) %>% 
  magrittr::set_names(names(mark_matrices)) %>% 
  bind_rows(.id = "mark") %>% 
  mutate(
    enrichment = center / outside,
    logenrich = log2(enrichment)
  )
```


```{r}
# Pivot the enrichment data into wide format, with 1 column for each mark
wide_enrich <- marks_enrich %>% 
  drop_na() %>% 
  select(boundary, mark, logenrich) %>% 
  pivot_wider(names_from = mark, values_from = logenrich) %>% 
  drop_na() %>% 
  filter(if_all(-boundary, is.finite))

# Perform UMAP transformation on the signal data
umap_base <- umap2(wide_enrich %>% select(-boundary)) %>% 
  as.data.frame()
```


```{r}
# Calculate the distance between all boundaries and cluster using hierarchical clustering
distances <- dist(wide_enrich %>% select(-boundary), method = "euclidean")
hclust_avg <- hclust(distances, method = 'ward.D')

# Minimum cluster size is 1% of boundaries
min_cluster_size <- floor(nrow(wide_enrich) / 100)

# res <- NbClust(wide_enrich %>% select(-boundary), diss = d, distance = NULL, method = "average", min.nc = 5, max.nc = 50)
# res$Best.nc[1,] %>% table()
```


```{r}
if (optimise_clusters) {
  n_clusters <- 2:15
  offset <- min(n_clusters) - 1
  base_dir <- "optimise_clustering/NC14_ward"
  
  
  iter_clusters <- lapply(
    n_clusters,
    function(n) {
      cutree(hclust_avg, k = n)
    }
  )
  
  for (idx in 1:length(iter_clusters)) {
    clusters <- iter_clusters[[idx]]
    
    # Create a list of boundariy IDs for each cluster
    boundaries_per_cluster <- wide_enrich %>% 
      mutate(cluster = clusters) %>% 
      select(boundary, cluster) %>% 
      group_by(cluster) %>% 
      summarise(
        b = list(boundary)
      ) %>% 
      tibble::deframe()
    
    # Get the size of each cluster
    sizes <- data.frame(
      cluster = as.factor(1:(idx + offset)),
      size = sapply(boundaries_per_cluster, length)
    )
    
    iter_umapped <- umap_base %>%
      mutate(
        cluster = clusters %>% as.factor(),
        cluster = forcats::fct_lump_min(cluster, min_cluster_size, other_level = NA)
      )
  
    ggplot(iter_umapped) +
      geom_point(aes(x = V1, y = V2, colour = cluster)) +
      labs(
        x = "UMAP 1",
        y = "UMAP 2",
        colour = "Cluster"
      ) +
      theme_bw() +
      theme(
        aspect.ratio = 1,
        panel.grid = element_blank(),
        axis.ticks = element_blank(),
        axis.text = element_blank()
      )
  
    ggsave(
      file.path(base_dir, paste0("umap_of_", idx + offset, "_clusters.pdf"))
    )
    
    # Get the average profiles for each mark in the top 3 clusters
    signal_per_cluster <- lapply(
      c(mark_names, atac_names, ins_names),
      function(target) {
        lapply(
          boundaries_per_cluster[sizes$size >= min_cluster_size],
          function(bounds) {
            mat <- mark_matrices[[target]][bounds, ]
            
            data.frame(
              mark = target,
              pos = (1:ncol(mat)) - 2500,
              mean = colMeans(mat),
              sd = apply(mat, 2, sd)
            )
          }
        ) %>% 
        bind_rows(.id = "cluster")
      }
    ) %>% 
      magrittr::set_names(c(mark_names, atac_names, ins_names)) %>% 
      bind_rows(.id = "mark") %>% 
      group_by(mark) %>% 
      mutate(
        norm = (mean - min(mean)) / (max(mean) - min(mean))
      )
  
    label_size <- sizes %>% 
      tibble::deframe() %>% 
      paste0("Cluster ", names(.), "\n(n = ", ., ")") %>% 
      magrittr::set_names(sizes$cluster) %>% 
      as_labeller()
  
  
    # Plot the average profile of each mark in each cluster
    profile_plot <- ggplot(signal_per_cluster, aes(x = pos)) +
      geom_line(aes(y = norm, group = mark, colour = cluster)) +
      facet_grid(mark ~ cluster, scales = "free_y", labeller = labeller(cluster = label_size)) +
      scale_x_continuous(
        breaks = c(-2000, 0, 2000),
        labels = scales::label_number(scale_cut = scales::cut_si(unit = "b")),
        expand = expansion(0)
      ) +
      scale_y_continuous(
        breaks = c(0, 0.5, 1),
        labels = c(0, "", 1)
      ) +
      # scale_colour_manual(
      #   values = cluster_colours
      # ) +
      guides(
        colour = "none"
      ) +
      labs(
        x = "Dist. to boundary center",
        y = "Normalized signal"
      ) +
      theme_bw() +
      theme(
        panel.grid.minor = element_blank(),
        strip.text.y = element_text(angle = 0),
        strip.background = element_blank()
      )
    
    ggsave(
      file.path(base_dir, paste0("signal_of_", idx + offset, "_clusters.pdf"))
    )
  }
  
  
  number_of_clusters <- sapply(
    iter_clusters,
    function(x) {
      sum(table(x) > min_cluster_size)
    }
  ) %>% 
    magrittr::set_names(n_clusters) %>% 
    data.frame(
      total_clusters = names(.),
      final_clusters = .
    )
  readr::write_tsv(number_of_clusters, file.path(base_dir, "number_of_clusters.tsv"))
}
```


```{r}
cluster_reordering <- c(
  "7" = "1",
  "8" = "2",
  "1" = "3",
  "3" = "4",
  "2" = "5",
  "4" = "6",
  "6" = "7",
  "9" = "8",
  "5" = "9"
)

# Assign each boundary to a cluster
clusters <- cluster_reordering[cutree(hclust_avg, k = 9) %>% as.character()] %>% unname()

# Create a list of boundariy IDs for each cluster
boundaries_per_cluster <- wide_enrich %>% 
  mutate(cluster = clusters) %>% 
  select(boundary, cluster) %>% 
  group_by(cluster) %>% 
  summarise(
    b = list(boundary)
  ) %>% 
  tibble::deframe()

# Perform PCA analysis for all boundaries
pca <- prcomp(wide_enrich %>% select(-boundary) %>% t(), scale. = TRUE, center = TRUE) %>% 
  summary()

# Plot the PCA results, colouring each dot by its cluster
df <- as.data.frame(pca$rotation) %>% 
  mutate(
    cluster = clusters %>% as.factor(),
    cluster = forcats::fct_lump_min(cluster, min_cluster_size, other_level = NA)
  )
pca_plot <- ggplot(df) +
  geom_point(aes(x = PC2, y = PC3, colour = cluster)) +
  scale_colour_manual(
    values = cluster_colours12,
    na.value = "#e2e2e2"
  ) +
  labs(
    x = paste0("PC2: ", round(pca$importance[2, 2] * 100, 1), "%"),
    y = paste0("PC3: ", round(pca$importance[2, 3] * 100, 1), "%"),
    colour = "Cluster"
  ) +
  theme_bw() +
  theme(
    aspect.ratio = 1,
    panel.grid.minor = element_blank()
  )
pca_plot
ggsave("results/2_pca_plot_of_clusters.pdf", pca_plot)
```


```{r}
umapped <- umap_base %>% 
  mutate(
    cluster = clusters %>% as.factor(),
    cluster = forcats::fct_lump_min(cluster, min_cluster_size, other_level = NA)
  )

umap_plot <- ggplot(umapped) +
  rasterise(geom_point(aes(x = V1, y = V2, colour = cluster)), dpi = 300) +
  scale_colour_manual(
    values = cluster_colours12,
    na.value = "#e2e2e2"
  ) +
  labs(
    x = "UMAP 1",
    y = "UMAP 2",
    colour = "Cluster"
  ) +
  theme_bw() +
  theme(
    aspect.ratio = 1,
    panel.grid = element_blank()
  )
umap_plot
ggsave("results/3_umap_plot_of_clusters.pdf", umap_plot)
```


```{r}
# Get the size of each cluster
sizes <- data.frame(
  cluster = as.factor(1:9),
  size = sapply(boundaries_per_cluster, length)
)

# Plot the size of each cluster
size_plot <- ggplot(sizes) +
  geom_col(aes(x = cluster, y = size, fill = cluster)) +
  scale_y_continuous(
    expand = expansion(mult = c(0.01, 0.05))
  ) +
  scale_fill_manual(
    values = cluster_colours12,
    na.value = "#e2e2e2"
  ) +
  labs(
    x = "Cluster",
    y = "Number of boundaries",
    fill = "Cluster"
  ) +
  theme_bw() +
  theme(
    panel.grid.minor = element_blank()
  )
size_plot
ggsave("results/4_size_of_clusters.pdf", size_plot)

# How many boundaries are in clusters with minimum size
sizes %>% 
  group_by(size >= min_cluster_size) %>% 
  summarise(
    total = sum(size)
  )
```


```{r}
# Set the order in which the marks are arranged
mark_levels <- c(
  "ATAC_mono",
  "ATAC_open",
  "BEAF",
  "CTCF",
  "CP190",
  "SUHW",
  "CLAMP",
  "GAF",
  "Zld",
  "TBP",
  "PolII",
  "RNA",
  "H3K4me3",
  "H3K36me3",
  "H4K16ac",
  "H3K27me3"
)

# Get the average profiles for each mark in the top 3 clusters
signal_per_cluster <- lapply(
  c(mark_names, atac_names, ins_names),
  function(target) {
    lapply(
      boundaries_per_cluster[sapply(boundaries_per_cluster, length) >= min_cluster_size],
      function(bounds) {
        mat <- mark_matrices[[target]][bounds, ]
        
        data.frame(
          mark = target,
          pos = (1:ncol(mat)) - 2500,
          mean = colMeans(mat),
          sd = apply(mat, 2, sd)
        )
      }
    ) %>% 
    bind_rows(.id = "cluster")
  }
) %>% 
  magrittr::set_names(c(mark_names, atac_names, ins_names)) %>% 
  bind_rows(.id = "mark") %>% 
  group_by(mark) %>% 
  mutate(
    norm = (mean - min(mean)) / (max(mean) - min(mean)),
    mark = factor(mark, levels = mark_levels)
  )

label_size <- sizes %>% 
  tibble::deframe() %>% 
  paste0("Cluster ", names(.), "\n(n = ", ., ")") %>% 
  magrittr::set_names(sizes$cluster) %>% 
  as_labeller()


# Plot the average profile of each mark in each cluster
profile_plot <- ggplot(signal_per_cluster, aes(x = pos)) +
  rasterise(geom_line(aes(y = norm, group = mark, colour = cluster)), dpi = 300) +
  # facet_wrap(~ quantile, nrow = 2) +
  facet_grid(mark ~ cluster, scales = "free_y", labeller = labeller(cluster = label_size)) +
  scale_x_continuous(
    breaks = c(-2000, 0, 2000),
    labels = scales::label_number(scale_cut = scales::cut_si(unit = "b")),
    expand = expansion(0)
  ) +
  scale_y_continuous(
    breaks = c(0, 0.5, 1),
    labels = c(0, "", 1)
  ) +
  scale_colour_manual(
    values = cluster_colours12
  ) +
  guides(
    colour = "none"
  ) +
  labs(
    x = "Dist. to boundary center",
    y = "Normalized signal"
  ) +
  theme_bw() +
  theme(
    panel.grid.minor = element_blank(),
    strip.text.y = element_text(angle = 0),
    strip.background = element_blank()
  )
profile_plot
ggsave("results/5_average_profile_per_cluster.pdf", profile_plot, width = 7*1.2, height = 6*1.2)
```


```{r}
# Get the boundary strengths for all boundaries per cluster
scores <- lapply(
  which(sapply(boundaries_per_cluster, length) >= min_cluster_size),
  function(cluster) {
    data.frame(
      cluster = cluster,
      score = boundaries_ext[boundaries_per_cluster[[cluster]]]$score
    )
  }
) %>% 
  bind_rows() %>% 
  mutate(
    cluster = as.factor(cluster)
  )
# Plot the distribution of boundary strengths across all clusters
strength_plot <- ggplot(scores, aes(x = cluster, y = score)) +
  geom_violin(aes(fill = cluster), scale = "width") +
  geom_boxplot(width = 0.3) +
  scale_fill_manual(values = cluster_colours12) +
  coord_cartesian(ylim = c(0, 4)) +
  guides(
    fill = "none"
  ) +
  labs(
    x = "Cluster",
    y = "Boundary strength"
  ) +
  theme_bw() +
  theme(
    panel.grid.minor = element_blank()
  )
strength_plot
ggsave("results/6_boundary_strength_per_cluster.pdf", strength_plot, width = 7, height = 4)
```


```{r}
# Create a list of the cluster each boundary falls in
boundary_clusters <- wide_enrich %>% 
  mutate(cluster = clusters) %>% 
  select(boundary, cluster) %>% 
  tibble::deframe() %>% 
  magrittr::extract(as.character(1:length(boundaries)))

# Add a new column of the cluster to all boundaries
boundaries$name <- boundary_clusters
boundaries_ext$cluster <- boundary_clusters

# Write the boundaries with cluster info to a file
export.bed(
  boundaries,
  "boundaries/NC14_0.45_16kb_500bp_boundaries_cluster.nocento.bed"
)

# Create a GRanges for the 4 boundaries at pair rule genes
selected <- c(
  "chr3R 6871001-6871500",
  "chr3R 6854001-6854500",
  "chr2R 9988501-9989000",
  "chr2R 9973001-9973500"
) %>% 
  str_split("[ -]") %>% 
  lapply(function(x) { as.data.frame.list(x) %>% magrittr::set_colnames(c("chrom", "start", "end")) }) %>% 
  bind_rows() %>% 
  makeGRangesFromDataFrame()

# Get the cluster information for the pair rule gene boundaries
hits <- findOverlaps(selected, boundaries_ext)
boundaries_ext[subjectHits(hits)]
```

```{r}
# Get the GAF and Zld enrichment values for all boundaries in the Zld-specific (3) and GAF + Zld (4) clusters
slim_enrich <- wide_enrich %>% 
  select(-BEAF, -CTCF, -CP190, -SUHW) %>%
  # select(boundary, GAF, Zld) %>% 
  filter(boundary %in% c(boundaries_per_cluster[["3"]], boundaries_per_cluster[["4"]]))

# Perform UMAP transformation on the signal data
slim_umap_base <- umap2(slim_enrich %>% select(-boundary)) %>% 
  as.data.frame()


# Perform hierarchical clustering based on GAF and Zld enrichment
slim_distances <- dist(slim_enrich %>% select(-boundary), method = "euclidean")
slim_hclust_avg <- hclust(slim_distances, method = 'ward.D')
```


```{r}
slim_clusters <- cutree(slim_hclust_avg, k = 3)

slim_umapped <- slim_umap_base %>% 
  mutate(
    cluster = slim_clusters %>% as.factor(),
    cluster = forcats::fct_lump_min(cluster, min_cluster_size, other_level = NA)
  )

ggplot(slim_umapped) +
  geom_point(aes(x = V1, y = V2, colour = cluster)) +
  scale_colour_manual(
    values = cluster_colours12,
    na.value = "#e2e2e2"
  ) +
  labs(
    x = "UMAP 1",
    y = "UMAP 2",
    colour = "Cluster"
  ) +
  theme_bw() +
  theme(
    aspect.ratio = 1,
    panel.grid = element_blank(),
    axis.ticks = element_blank(),
    axis.text = element_blank()
  )


# Create a list of boundary IDs for each cluster
slim_boundaries <- slim_enrich %>% 
  mutate(cluster = slim_clusters) %>% 
  select(boundary, cluster) %>% 
  group_by(cluster) %>% 
  summarise(
    b = list(boundary)
  ) %>% 
  tibble::deframe()


slim_signals <- lapply(
  c(mark_names, atac_names, ins_names),
  function(target) {
    lapply(
      slim_boundaries[sapply(slim_boundaries, length) >= 2],
      function(bounds) {
        mat <- mark_matrices[[target]][bounds, ]
        
        data.frame(
          mark = target,
          pos = (1:ncol(mat)) - 2500,
          mean = colMeans(mat),
          sd = apply(mat, 2, sd)
        )
      }
    ) %>% 
    bind_rows(.id = "cluster")
  }
) %>% 
  magrittr::set_names(c(mark_names, atac_names, ins_names)) %>% 
  bind_rows(.id = "mark") %>% 
  group_by(mark) %>% 
  mutate(
    norm = (mean - min(mean)) / (max(mean) - min(mean)),
    mark = factor(mark, levels = mark_levels)
  ) %>% 
  ungroup() %>% 
  # filter(mark %in% c("Zld", "GAF"))
  filter(!mark %in% c("BEAF", "CTCF", "CP190", "SUHW"))

slim_label <- sapply(
    slim_boundaries,
    length
  ) %>% 
  # tibble::deframe() %>% 
  paste0("Cluster ", names(.), "\n(n = ", ., ")") %>% 
  magrittr::set_names(1:length(slim_boundaries)) %>% 
  as_labeller()


# Plot the average profile of each mark in each cluster
ggplot(slim_signals, aes(x = pos)) +
  geom_line(aes(y = norm, group = mark, colour = cluster)) +
  # facet_wrap(~ quantile, nrow = 2) +
  facet_grid(mark ~ cluster, scales = "free_y", labeller = labeller(cluster = slim_label)) +
  scale_x_continuous(
    breaks = c(-2000, 0, 2000),
    labels = scales::label_number(scale_cut = scales::cut_si(unit = "b")),
    expand = expansion(0)
  ) +
  scale_y_continuous(
    breaks = c(0, 0.5, 1),
    labels = c(0, "", 1)
  ) +
  scale_colour_manual(
    values = cluster_colours12
  ) +
  guides(
    colour = "none"
  ) +
  labs(
    x = "Dist. to boundary center",
    y = "Normalized signal"
  ) +
  theme_bw() +
  theme(
    panel.grid.minor = element_blank(),
    strip.text.y = element_text(angle = 0),
    strip.background = element_blank()
  )
```
